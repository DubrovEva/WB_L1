package main

import (
	"fmt"
	"log"
	"math/rand"
)

/*
	Реализовать быструю сортировку массива (quicksort) встроенными методами языка.
*/

func quickSort(a []int) []int {
	if len(a) < 2 {
		// массив из одного элемента всегда отсортирован
		return a
	}

	// левая и правая граница массива
	left, right := 0, len(a)-1

	// элемент-разделитель выбирается случайно для улучшения асимптотики
	pivotIndex := rand.Int() % len(a)

	// разделителя ставим в конец для удобства
	a[pivotIndex], a[right] = a[right], a[pivotIndex]

	// проходимся по массиву
	for i := range a {
		// если текущий элемент меньше разделителя, то его можно поменять с левой границей, а границу подвинуть на один
		// таким образом сохраняется инвариант, что все элементы меньше разделителя лежат до левой границы
		// в случае, если элемент больше разделителя, он останется на месте левой границы, и его могут поменять на следующем шаге

		if a[i] < a[right] {
			a[i], a[left] = a[left], a[i]
			left++
		}
	}

	// последний обмен для того, чтобы последний элемент, который больше разделителя, оказался справа от него
	// left не мог быть меньше разделителя, поскольку в таком случае он бы увеличился на один, то есть в худшем случае одни равны
	a[left], a[right] = a[right], a[left]

	// теперь сортируем две части массива, до и после разделителя
	quickSort(a[:left])
	quickSort(a[left+1:])

	return a
}

func testQuickSort() error {
	n := 10
	for testNum := 1; testNum < 5; testNum++ {
		arr := rand.Perm(n)
		result := quickSort(arr)

		for i := 0; i < n-1; i++ {
			if arr[i] > arr[i+1] {
				return fmt.Errorf("массив не отсортирован. Тест: %v, результат: %v", arr, result)
			}
		}

	}

	return nil
}

func main() {
	err := testQuickSort()
	if err != nil {
		log.Fatalf("Ошибка при тесте: %v", err)
	}
	log.Println("Все тесты пройдены")
}
